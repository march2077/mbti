<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ NaNa Grand Luxury Tree</title>
    
    <!-- 1. ÈåØË™§ÂÅµÊ∏¨Á≥ªÁµ± -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:#ff5555; padding:20px; z-index:9999; overflow:auto; font-family:monospace; font-size:16px; white-space: pre-wrap;';
            div.innerHTML = `<h3>‚ö†Ô∏è Á®ãÂºèÂü∑Ë°åÈåØË™§ (Debug Mode)</h3><p><strong>Error:</strong> ${msg}</p><p><strong>File:</strong> ${url}</p><p><strong>Line:</strong> ${line}:${col}</p><hr/><p>Ë´ãÊà™ÂúñÊ≠§Áï´Èù¢‰ª•ÈÄ≤Ë°åÈô§ÈåØ„ÄÇ</p>`;
            document.body.appendChild(div);
            return false;
        };
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050505; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 40px;
        }
        h1 {
            font-family: 'Cinzel', serif; color: #d4af37; text-align: center;
            font-size: 3rem; text-shadow: 0 0 20px rgba(212,175,55,0.6); margin: 0;
            letter-spacing: 5px;
        }
        .btn {
            pointer-events: auto; margin: 0 auto;
            background: linear-gradient(45deg, #d4af37, #f9f295, #d4af37);
            border: none; padding: 15px 40px; font-size: 1.2rem; font-family: 'Cinzel', serif; font-weight: bold;
            color: #1a1a1a; cursor: pointer; border-radius: 50px;
            box-shadow: 0 0 30px rgba(212,175,55,0.4);
            transition: transform 0.3s;
        }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(212,175,55,0.8); }
    </style>

    <!-- 2. Import Maps (ÈóúÈçµ‰øÆÂæ©ÔºöÂä†ÂÖ• jsx-runtime) -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
            "react/jsx-dev-runtime": "https://esm.sh/react@18.2.0/jsx-dev-runtime",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
            "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
            "uuid": "https://esm.sh/uuid@9.0.1"
        }
    }
    </script>
    <!-- Babel Ë®≠ÁΩÆ -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Float, Sparkles, Image as DreiImage, Environment, Html } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';

        // --- ÂúñÁâáË∑ØÂæë ---
        const PHOTO_PATHS = [
            "images/INTJ_boy.jpg", "images/INTJ_girl.jpg", "images/INTP_boy.jpg", "images/INTP_girl.jpg",
            "images/ENTJ_boy.jpg", "images/ENTJ_girl.jpg", "images/ENTP_boy.jpg", "images/ENTP_girl.jpg",
            "images/INFJ_boy.jpg", "images/INFJ_girl.jpg", "images/INFP_boy.jpg", "images/INFP_girl.jpg",
            "images/ENFJ_boy.jpg", "images/ENFJ_girl.jpg", "images/ENFP_boy.jpg", "images/ENFP_girl.jpg",
            "images/ISTJ_boy.jpg", "images/ISTJ_girl.jpg", "images/ISFJ_boy.jpg", "images/ISFJ_girl.jpg",
            "images/ESTJ_boy.jpg", "images/ESTJ_girl.jpg", "images/ESFJ_boy.jpg", "images/ESFJ_girl.jpg",
            "images/ISTP_boy.jpg", "images/ISTP_girl.jpg", "images/ISFP_boy.jpg", "images/ISFP_girl.jpg",
            "images/ESTP_boy.jpg", "images/ESTP_girl.jpg", "images/ESFP_boy.jpg", "images/ESFP_girl.jpg"
        ];

        // --- ËºîÂä©ÂêëÈáèÂáΩÊï∏ ---
        const randomVector = (r) => {
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        const treeVector = (i, count) => {
            const y = (i / count) * 16 - 8; 
            const radius = 6 * (1 - (i / count)); 
            const angle = i * 0.5;
            return new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
        }

        // --- Á≤íÂ≠êÊ®π ---
        function MagicTree({ isFormed }) {
            const count = 2000;
            const mesh = useRef();
            
            const { dummy, particles } = useMemo(() => {
                const dummy = new THREE.Object3D();
                const particles = new Array(count).fill(0).map((_, i) => ({
                    target: treeVector(i, count),
                    chaos: randomVector(12),
                    current: randomVector(12),
                    scale: Math.random() * 0.3 + 0.1,
                    color: Math.random() > 0.8 ? '#d4af37' : '#046307'
                }));
                return { dummy, particles };
            }, []);

            useFrame((state) => {
                if(!mesh.current) return;
                particles.forEach((p, i) => {
                    const target = isFormed ? p.target : p.chaos;
                    p.current.lerp(target, 0.05);
                    
                    dummy.position.copy(p.current);
                    if(isFormed) dummy.position.y += Math.sin(state.clock.elapsedTime + i) * 0.05;
                    else dummy.rotation.x += 0.01;

                    dummy.scale.setScalar(p.scale);
                    dummy.updateMatrix();
                    mesh.current.setMatrixAt(i, dummy.matrix);
                    mesh.current.setColorAt(i, new THREE.Color(p.color));
                });
                mesh.current.instanceMatrix.needsUpdate = true;
                if(mesh.current.instanceColor) mesh.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={mesh} args={[null, null, count]}>
                    <sphereGeometry args={[1, 8, 8]} />
                    <meshBasicMaterial toneMapped={false} />
                </instancedMesh>
            );
        }

        // --- ÊãçÁ´ãÂæó ---
        function Polaroid({ url, index, isFormed, isUnleashed, setZoom, zoomedId }) {
            const group = useRef();
            const [hovered, setHover] = useState(false);
            
            const { treePos, chaosPos, chaosRot } = useMemo(() => {
                const t = treeVector(index * (2000/32), 2000).multiplyScalar(1.2);
                return {
                    treePos: t,
                    chaosPos: randomVector(18),
                    chaosRot: [Math.random()*3, Math.random()*3, 0]
                }
            }, [index]);

            useFrame((state) => {
                if(!group.current) return;
                const isZoomed = zoomedId === index;
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Quaternion();
                let targetScale = 1;

                if (isZoomed) {
                    const cam = state.camera;
                    const offset = new THREE.Vector3(0, 0, -6).applyQuaternion(cam.quaternion);
                    targetPos.copy(cam.position).add(offset);
                    targetRot.copy(cam.quaternion);
                    targetScale = 3;
                } else {
                    targetPos = isFormed ? treePos : chaosPos;
                    if(isFormed) {
                        const dummy = new THREE.Object3D();
                        dummy.position.copy(targetPos);
                        dummy.lookAt(0, targetPos.y, 0); 
                        targetRot.setFromEuler(dummy.rotation);
                    } else {
                        const dummy = new THREE.Object3D();
                        dummy.rotation.set(...chaosRot);
                        targetRot.setFromEuler(dummy.rotation);
                        targetPos.y += Math.sin(state.clock.elapsedTime + index) * 0.02;
                    }
                    targetScale = (hovered && isUnleashed) ? 1.5 : 1;
                }

                group.current.position.lerp(targetPos, 0.1);
                group.current.quaternion.slerp(targetRot, 0.1);
                group.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            });

            return (
                <group ref={group}
                    onClick={(e) => { e.stopPropagation(); if(isUnleashed) setZoom(zoomedId === index ? null : index); }}
                    onPointerOver={() => isUnleashed && setHover(true)}
                    onPointerOut={() => setHover(false)}
                >
                    <mesh position={[0,0,-0.05]}>
                        <boxGeometry args={[1.2, 1.5, 0.05]} />
                        <meshStandardMaterial color="#fff" roughness={0.5} />
                    </mesh>
                    <DreiImage url={url} position={[0, 0.15, 0.01]} scale={[1, 1, 1]} transparent />
                    <mesh position={[0,-0.6,0.01]}>
                         <planeGeometry args={[0.8, 0.1]} />
                         <meshBasicMaterial color="#eee" />
                    </mesh>
                </group>
            );
        }

        // --- ‰∏ªÂ†¥ÊôØ ---
        function Scene() {
            const [mode, setMode] = useState('FORMED');
            const [zoomedId, setZoom] = useState(null);
            const isFormed = mode === 'FORMED';

            return (
                <>
                    <Html fullscreen style={{pointerEvents: 'none'}}>
                        <div id="ui">
                            <div>
                                <h1>üêæ NaNa's Christmas</h1>
                                <p style={{textAlign:'center', color:'#d4af37', fontFamily:'monospace'}}>Luxury Edition</p>
                            </div>
                            <button className="btn" onClick={() => { setMode(isFormed ? 'CHAOS' : 'FORMED'); setZoom(null); }}>
                                {isFormed ? "UNLEASH CHAOS" : "FORM TREE"}
                            </button>
                        </div>
                    </Html>

                    <PerspectiveCamera makeDefault position={[0, 0, 25]} fov={45} />
                    <OrbitControls enablePan={false} maxDistance={40} minDistance={5} autoRotate={isFormed} autoRotateSpeed={0.5} />
                    
                    <ambientLight intensity={0.5} color="#d4af37" />
                    <pointLight position={[10, 10, 10]} intensity={2} color="#ff0000" />
                    <pointLight position={[-10, -10, -10]} intensity={2} color="#00ff00" />

                    <group position={[0, -2, 0]}>
                        <MagicTree isFormed={isFormed} />
                        <Float speed={2} rotationIntensity={1} floatIntensity={1}>
                            <Sparkles count={100} scale={12} size={4} speed={0.4} opacity={0.5} color="#d4af37" />
                        </Float>
                        {PHOTO_PATHS.map((path, i) => (
                            <Polaroid key={i} index={i} url={path} isFormed={isFormed} isUnleashed={!isFormed} setZoom={setZoom} zoomedId={zoomedId} />
                        ))}
                    </group>

                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.5} mipmapBlur intensity={1.5} radius={0.6} />
                        <Noise opacity={0.02} />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </>
            );
        }

        // --- App ---
        function App() {
            return (
                <Canvas gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }}>
                    <color attach="background" args={['#050505']} />
                    <Suspense fallback={null}>
                        <Scene />
                    </Suspense>
                </Canvas>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
