<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ NaNa Grand Luxury Tree</title>
    
    <!-- 1. éŒ¯èª¤åµæ¸¬ç³»çµ± (è‹¥é»‘ç•«é¢æœƒé¡¯ç¤ºåŸå› ) -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:red; padding:20px; z-index:9999; overflow:auto; font-family:monospace; font-size:16px;';
            div.innerHTML = `<h3>âš ï¸ ç¨‹å¼åŸ·è¡ŒéŒ¯èª¤</h3><p><strong>Error:</strong> ${msg}</p><p><strong>Location:</strong> ${url}:${line}:${col}</p><p>è«‹ç¢ºä¿æ‚¨ä½¿ç”¨ <strong>Live Server</strong> é–‹å•Ÿï¼Œè€Œéç›´æ¥é›™æ“Šæª”æ¡ˆã€‚</p>`;
            document.body.appendChild(div);
            return false;
        };
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050505; }
        
        /* UI æ¨£å¼ */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 40px;
        }
        h1 {
            font-family: 'Cinzel', serif; color: #d4af37; text-align: center;
            font-size: 3rem; text-shadow: 0 0 20px rgba(212,175,55,0.6); margin: 0;
            letter-spacing: 5px;
        }
        .btn {
            pointer-events: auto; margin: 0 auto;
            background: linear-gradient(45deg, #d4af37, #f9f295, #d4af37);
            border: none; padding: 15px 40px; font-size: 1.2rem; font-family: 'Cinzel', serif; font-weight: bold;
            color: #1a1a1a; cursor: pointer; border-radius: 50px;
            box-shadow: 0 0 30px rgba(212,175,55,0.4);
            transition: transform 0.3s;
        }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(212,175,55,0.8); }
        .loading { position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); color: #d4af37; font-family: monospace; }
    </style>

    <!-- 2. Import Maps (æ ¸å¿ƒä¾è³´) -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
            "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three",
            "uuid": "https://esm.sh/uuid@9.0.1"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, Suspense, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Float, Sparkles, Image as DreiImage, Environment, useTexture } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';

        // --- è¨­å®šèˆ‡è·¯å¾‘ ---
        // è«‹ç¢ºä¿ images è³‡æ–™å¤¾å­˜åœ¨ï¼Œä¸”æª”åæ­£ç¢ºã€‚å¦‚æœæ²’æœ‰åœ–ç‰‡ï¼Œé€™è£¡æœƒè‡ªå‹•ä½¿ç”¨ç¶²è·¯åœ–ç•¶å‚™æ¡ˆã€‚
        const PHOTO_PATHS = [
            "images/INTJ_boy.jpg", "images/INTJ_girl.jpg", "images/INTP_boy.jpg", "images/INTP_girl.jpg",
            "images/ENTJ_boy.jpg", "images/ENTJ_girl.jpg", "images/ENTP_boy.jpg", "images/ENTP_girl.jpg",
            "images/INFJ_boy.jpg", "images/INFJ_girl.jpg", "images/INFP_boy.jpg", "images/INFP_girl.jpg",
            "images/ENFJ_boy.jpg", "images/ENFJ_girl.jpg", "images/ENFP_boy.jpg", "images/ENFP_girl.jpg",
            "images/ISTJ_boy.jpg", "images/ISTJ_girl.jpg", "images/ISFJ_boy.jpg", "images/ISFJ_girl.jpg",
            "images/ESTJ_boy.jpg", "images/ESTJ_girl.jpg", "images/ESFJ_boy.jpg", "images/ESFJ_girl.jpg",
            "images/ISTP_boy.jpg", "images/ISTP_girl.jpg", "images/ISFP_boy.jpg", "images/ISFP_girl.jpg",
            "images/ESTP_boy.jpg", "images/ESTP_girl.jpg", "images/ESFP_boy.jpg", "images/ESFP_girl.jpg"
        ];

        // --- æ•¸å­¸å·¥å…· (ç”Ÿæˆèºæ—‹æ¨¹) ---
        const randomVector = (r) => {
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        const treeVector = (i, count) => {
            const y = (i / count) * 16 - 8; // Height from -8 to 8
            const radius = 6 * (1 - (i / count)); // Cone shape
            const angle = i * 0.5; // Spiral density
            return new THREE.Vector3(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );
        }

        // --- æ ¸å¿ƒçµ„ä»¶ï¼šé­”å¹»ç²’å­æ¨¹ ---
        function MagicTree({ isFormed }) {
            const count = 2000;
            const mesh = useRef();
            
            // åˆå§‹åŒ–æ•¸æ“šï¼šChaos(éš¨æ©Ÿ) vs Target(æ¨¹å½¢)
            const { dummy, particles } = useMemo(() => {
                const dummy = new THREE.Object3D();
                const particles = new Array(count).fill(0).map((_, i) => {
                    const t = treeVector(i, count);
                    const c = randomVector(12);
                    return {
                        target: t,
                        chaos: c,
                        current: c.clone(), // ç•¶å‰ä½ç½®
                        scale: Math.random() * 0.3 + 0.1,
                        color: Math.random() > 0.8 ? '#d4af37' : '#046307' // é‡‘è‰²å°‘ï¼Œç¶ è‰²å¤š
                    };
                });
                return { dummy, particles };
            }, []);

            useFrame((state) => {
                if(!mesh.current) return;
                
                particles.forEach((p, i) => {
                    // 1. è¨ˆç®—ç›®æ¨™ä½ç½®
                    const target = isFormed ? p.target : p.chaos;
                    
                    // 2. ç§»å‹•é‚è¼¯ (Lerp)
                    p.current.lerp(target, 0.05);
                    
                    // 3. åŠ ä¸Šä¸€é»ã€Œå‘¼å¸ã€æµ®å‹•
                    const wave = Math.sin(state.clock.elapsedTime + i) * 0.05;
                    
                    dummy.position.copy(p.current);
                    if(isFormed) dummy.position.y += wave; // åªæœ‰æ¨¹å‹æ…‹æ‰ä¸Šä¸‹æµ®å‹•
                    else dummy.rotation.x += 0.01; // æ··äº‚å‹æ…‹æœƒè‡ªè½‰

                    dummy.scale.setScalar(p.scale);
                    dummy.updateMatrix();
                    
                    mesh.current.setMatrixAt(i, dummy.matrix);
                    mesh.current.setColorAt(i, new THREE.Color(p.color));
                });
                mesh.current.instanceMatrix.needsUpdate = true;
                if(mesh.current.instanceColor) mesh.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={mesh} args={[null, null, count]}>
                    <sphereGeometry args={[1, 8, 8]} /> {/* ä½é¢æ•¸çƒé«”å„ªåŒ–æ•ˆèƒ½ */}
                    <meshBasicMaterial toneMapped={false} /> {/* BasicMaterial ç™¼å…‰æ•ˆæœæœ€å¥½ */}
                </instancedMesh>
            );
        }

        // --- æ ¸å¿ƒçµ„ä»¶ï¼šæ‹ç«‹å¾—ç…§ç‰‡ç‰† ---
        function Polaroid({ url, index, isFormed, isUnleashed, setZoom, zoomedId }) {
            const group = useRef();
            const [hovered, setHover] = useState(false);
            
            // è¨ˆç®—ä½ç½®
            const { treePos, chaosPos, chaosRot } = useMemo(() => {
                const t = treeVector(index * (2000/32), 2000); // åˆ†æ•£åœ¨æ¨¹çš„èºæ—‹ç·šä¸Š
                t.multiplyScalar(1.2); // ç¨å¾®å¾€å¤–æ¨ä¸€é»ï¼Œæµ®åœ¨æ¨¹è‘‰ä¸Š
                return {
                    treePos: t,
                    chaosPos: randomVector(18),
                    chaosRot: [Math.random()*3, Math.random()*3, 0]
                }
            }, [index]);

            useFrame((state) => {
                if(!group.current) return;
                
                const isZoomed = zoomedId === index;
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Quaternion();
                let targetScale = 1;

                if (isZoomed) {
                    // æ”¾å¤§æ¨¡å¼ï¼šé£›åˆ°ç›¸æ©Ÿå‰é¢
                    const cam = state.camera;
                    const offset = new THREE.Vector3(0, 0, -6).applyQuaternion(cam.quaternion);
                    targetPos.copy(cam.position).add(offset);
                    targetRot.copy(cam.quaternion);
                    targetScale = 3;
                } else {
                    // æ™®é€šæ¨¡å¼
                    targetPos = isFormed ? treePos : chaosPos;
                    if(isFormed) {
                        // æ¨¹æ¨¡å¼ï¼šé¢æœä¸­å¿ƒï¼Œç„¶å¾Œè½‰éä¾†é¢æœå¤–
                        const dummy = new THREE.Object3D();
                        dummy.position.copy(targetPos);
                        dummy.lookAt(0, targetPos.y, 0); 
                        targetRot.setFromEuler(dummy.rotation);
                    } else {
                        // æ··äº‚æ¨¡å¼ï¼šéš¨æ©Ÿæ—‹è½‰
                        const dummy = new THREE.Object3D();
                        dummy.rotation.set(...chaosRot);
                        targetRot.setFromEuler(dummy.rotation);
                        targetPos.y += Math.sin(state.clock.elapsedTime + index) * 0.02; // æ¼‚æµ®
                    }
                    targetScale = (hovered && isUnleashed) ? 1.5 : 1;
                }

                // å‹•ç•«æ’å€¼
                group.current.position.lerp(targetPos, 0.1);
                group.current.quaternion.slerp(targetRot, 0.1);
                group.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            });

            return (
                <group ref={group}
                    onClick={(e) => { e.stopPropagation(); if(isUnleashed) setZoom(zoomedId === index ? null : index); }}
                    onPointerOver={() => isUnleashed && setHover(true)}
                    onPointerOut={() => setHover(false)}
                >
                    {/* ç™½é‚Šæ¡† */}
                    <mesh position={[0,0,-0.05]}>
                        <boxGeometry args={[1.2, 1.5, 0.05]} />
                        <meshStandardMaterial color="#fff" roughness={0.5} />
                    </mesh>
                    {/* ç…§ç‰‡æœ¬é«” (ä½¿ç”¨ Suspense é˜²çˆ†) */}
                    <Suspense fallback={<mesh><planeGeometry /><meshBasicMaterial color="gray"/></mesh>}>
                        <DreiImage url={url} position={[0, 0.15, 0.01]} scale={[1, 1, 1]} transparent />
                    </Suspense>
                    <mesh position={[0,-0.6,0.01]}>
                         <planeGeometry args={[0.8, 0.1]} />
                         <meshBasicMaterial color="#eee" />
                    </mesh>
                </group>
            );
        }

        // --- ä¸»å ´æ™¯ ---
        function Scene() {
            const [mode, setMode] = useState('FORMED'); // FORMED | CHAOS
            const [zoomedId, setZoom] = useState(null);
            const isFormed = mode === 'FORMED';

            return (
                <>
                    {/* UI å±¤ (HTML) */}
                    <Html fullscreen style={{pointerEvents: 'none'}}>
                        <div id="ui">
                            <div>
                                <h1>ğŸ¾ NaNa's Christmas</h1>
                                <p style={{textAlign:'center', color:'#d4af37', fontFamily:'monospace'}}>Luxury Edition</p>
                            </div>
                            <button className="btn" onClick={() => { setMode(isFormed ? 'CHAOS' : 'FORMED'); setZoom(null); }}>
                                {isFormed ? "UNLEASH CHAOS" : "FORM TREE"}
                            </button>
                        </div>
                    </Html>

                    {/* 3D å…§å®¹ */}
                    <PerspectiveCamera makeDefault position={[0, 0, 25]} fov={45} />
                    <OrbitControls enablePan={false} maxDistance={40} minDistance={5} autoRotate={isFormed} autoRotateSpeed={0.5} />
                    
                    {/* ç‡ˆå…‰ */}
                    <ambientLight intensity={0.5} color="#d4af37" />
                    <pointLight position={[10, 10, 10]} intensity={2} color="#ff0000" />
                    <pointLight position={[-10, -10, -10]} intensity={2} color="#00ff00" />

                    <group position={[0, -2, 0]}>
                        {/* ç²’å­æ¨¹ */}
                        <MagicTree isFormed={isFormed} />
                        
                        {/* é–ƒäº®ç‰¹æ•ˆ */}
                        <Float speed={2} rotationIntensity={1} floatIntensity={1}>
                            <Sparkles count={100} scale={12} size={4} speed={0.4} opacity={0.5} color="#d4af37" />
                        </Float>

                        {/* ç…§ç‰‡ç‰† */}
                        {PHOTO_PATHS.map((path, i) => (
                            <Polaroid 
                                key={i} 
                                index={i} 
                                url={path} 
                                isFormed={isFormed}
                                isUnleashed={!isFormed}
                                setZoom={setZoom}
                                zoomedId={zoomedId}
                            />
                        ))}
                    </group>

                    {/* å¾Œè£½ç‰¹æ•ˆ (è¼å…‰) */}
                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.5} mipmapBlur intensity={1.5} radius={0.6} />
                        <Noise opacity={0.02} />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </>
            );
        }

        // --- æ‡‰ç”¨å…¥å£ ---
        function App() {
            return (
                <Canvas gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }}>
                    <color attach="background" args={['#050505']} />
                    <Suspense fallback={null}>
                        <Scene />
                    </Suspense>
                </Canvas>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
