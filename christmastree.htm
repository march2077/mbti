<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¾ NaNaçš„å¿«æ¨‚è–èª•ç¯€</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');
        
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000501; }
        .luxury-font { font-family: 'Cinzel', serif; }
        .hand-font { font-family: 'Playfair Display', serif; }
        
        .btn-luxury {
            background: linear-gradient(135deg, #d4af37 0%, #f9f295 50%, #aa8e28 100%);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            cursor: pointer;
            pointer-events: auto;
        }
        .btn-luxury:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.8); }

        /* ç¢ºä¿ UI åœ¨ Canvas ä¹‹ä¸Š */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
            "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Environment, Image as DreiImage, Html } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // --- è¨­å®šèˆ‡è·¯å¾‘ ---
        const PHOTO_PATHS = [
            "images/INTJ_boy.jpg", "images/INTJ_girl.jpg", "images/INTP_boy.jpg", "images/INTP_girl.jpg",
            "images/ENTJ_boy.jpg", "images/ENTJ_girl.jpg", "images/ENTP_boy.jpg", "images/ENTP_girl.jpg",
            "images/INFJ_boy.jpg", "images/INFJ_girl.jpg", "images/INFP_boy.jpg", "images/INFP_girl.jpg",
            "images/ENFJ_boy.jpg", "images/ENFJ_girl.jpg", "images/ENFP_boy.jpg", "images/ENFP_girl.jpg",
            "images/ISTJ_boy.jpg", "images/ISTJ_girl.jpg", "images/ISFJ_boy.jpg", "images/ISFJ_girl.jpg",
            "images/ESTJ_boy.jpg", "images/ESTJ_girl.jpg", "images/ESFJ_boy.jpg", "images/ESFJ_girl.jpg",
            "images/ISTP_boy.jpg", "images/ISTP_girl.jpg", "images/ISFP_boy.jpg", "images/ISFP_girl.jpg",
            "images/ESTP_boy.jpg", "images/ESTP_girl.jpg", "images/ESFP_boy.jpg", "images/ESFP_girl.jpg"
        ];

        const COUNT_NEEDLES = 3000;
        const COUNT_ORNAMENTS = 150;
        const COLORS = {
            GOLD: new THREE.Color("#FFD700"),
            EMERALD: new THREE.Color("#046307"),
            DEEP_RED: new THREE.Color("#8B0000"),
            SILVER: new THREE.Color("#C0C0C0")
        };

        // --- æ•¸å­¸è¼”åŠ© ---
        function getChaosPosition(radius) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            const r = radius * Math.cbrt(Math.random());
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        function getTreePosition(i, count, radiusBase, height) {
            const y = (i / count) * height; 
            const radius = radiusBase * (1 - y / height);
            const angle = i * 137.5 * (Math.PI / 180);
            return new THREE.Vector3(Math.cos(angle) * radius, y - height / 2, Math.sin(angle) * radius);
        }

        // --- 3D ç‰©ä»¶ (ä¸ä¾è³´å¤–éƒ¨è³‡æºï¼Œçµ•å°æœƒé¡¯ç¤º) ---

        // 1. é‡è‘‰
        const Foliage = ({ isFormed }) => {
            const pointsRef = useRef();
            const { positions, targets, chaos } = useMemo(() => {
                const pos = new Float32Array(COUNT_NEEDLES * 3);
                const targets = [], chaos = [];
                for (let i = 0; i < COUNT_NEEDLES; i++) {
                    const t = getTreePosition(i, COUNT_NEEDLES, 6, 14);
                    const c = getChaosPosition(15);
                    targets.push(t); chaos.push(c);
                    pos.set([c.x, c.y, c.z], i*3);
                }
                return { positions: pos, targets, chaos };
            }, []);

            useFrame((state) => {
                if (!pointsRef.current) return;
                const attr = pointsRef.current.geometry.attributes.position;
                for (let i = 0; i < COUNT_NEEDLES; i++) {
                    const ix = i * 3;
                    const cur = new THREE.Vector3(attr.array[ix], attr.array[ix+1], attr.array[ix+2]);
                    const tgt = isFormed ? targets[i] : chaos[i];
                    cur.lerp(tgt, isFormed ? 0.05 : 0.02);
                    if (!isFormed) cur.y += Math.sin(state.clock.elapsedTime + i) * 0.01;
                    attr.setXYZ(i, cur.x, cur.y, cur.z);
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={pointsRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={COUNT_NEEDLES} array={positions} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.15} color={COLORS.EMERALD} transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        // 2. è£é£¾çƒèˆ‡ç¦®ç‰©
        const Ornaments = ({ isFormed }) => {
            const meshRef = useRef();
            const tempObj = new THREE.Object3D();
            const data = useMemo(() => new Array(COUNT_ORNAMENTS).fill(0).map((_, i) => ({
                t: getTreePosition(i, COUNT_ORNAMENTS, 6.5, 14).add(new THREE.Vector3(Math.random()-.5, 0, Math.random()-.5)),
                c: getChaosPosition(18),
                color: Math.random()>.6 ? COLORS.GOLD : (Math.random()>.5 ? COLORS.DEEP_RED : COLORS.SILVER),
                scale: Math.random()*.4 + .2,
                current: getChaosPosition(18)
            })), []);

            useFrame(() => {
                if (!meshRef.current) return;
                data.forEach((obj, i) => {
                    const target = isFormed ? obj.t : obj.c;
                    obj.current.lerp(target, 0.03);
                    tempObj.position.copy(obj.current);
                    tempObj.rotation.set(isFormed?0:tempObj.position.x, isFormed?0:tempObj.position.y, 0);
                    tempObj.scale.setScalar(obj.scale);
                    tempObj.updateMatrix();
                    meshRef.current.setMatrixAt(i, tempObj.matrix);
                    meshRef.current.setColorAt(i, obj.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[null, null, COUNT_ORNAMENTS]}>
                    <sphereGeometry args={[1, 16, 16]} />
                    <meshStandardMaterial color="#fff" roughness={0.1} metalness={0.9} />
                </instancedMesh>
            );
        };

        // 3. æ‹ç«‹å¾—ç…§ç‰‡ (é€™æ˜¯å”¯ä¸€æœƒå› ç‚ºè·¯å¾‘éŒ¯èª¤è€Œå¤±æ•—çš„éƒ¨åˆ†ï¼Œæˆ‘å€‘å°‡å®ƒç¨ç«‹è™•ç†)
        const Polaroid = ({ index, isFormed, isUnleashedMode, setZoomedId, zoomedId, url }) => {
            const groupRef = useRef();
            const [hovered, setHover] = useState(false);
            const { treePos, chaosPos, rotChaos } = useMemo(() => {
                const t = getTreePosition(index, PHOTO_PATHS.length, 7, 12); t.y += 1;
                return { treePos: t, chaosPos: getChaosPosition(22), rotChaos: [Math.random()*Math.PI, Math.random()*Math.PI, 0] };
            }, [index]);

            useFrame((state) => {
                if (!groupRef.current) return;
                const isZoomed = zoomedId === index;
                let tPos = isZoomed ? state.camera.position.clone().add(new THREE.Vector3(0,0,-6).applyQuaternion(state.camera.quaternion)) : (isFormed ? treePos : chaosPos);
                let tRot = isZoomed ? state.camera.rotation : (isFormed ? new THREE.Euler(0,0,0) : new THREE.Euler(...rotChaos));
                
                if (isFormed && !isZoomed) {
                    groupRef.current.lookAt(0, tPos.y, 0);
                    tRot = groupRef.current.rotation;
                }
                if (!isFormed && !isZoomed) tPos.y += Math.sin(state.clock.elapsedTime + index)*0.05;
                const tScale = isZoomed ? 2.5 : ((hovered && isUnleashedMode) ? 1.3 : 1);

                groupRef.current.position.lerp(tPos, 0.08);
                if (isZoomed) groupRef.current.quaternion.slerp(state.camera.quaternion, 0.1);
                else groupRef.current.quaternion.slerp(new THREE.Quaternion().setFromEuler(tRot), 0.1);
                
                groupRef.current.scale.lerp(new THREE.Vector3(tScale,tScale,tScale), 0.1);
            });

            return (
                <group ref={groupRef} 
                    onClick={(e) => { e.stopPropagation(); if(isUnleashedMode) setZoomedId(zoomedId === index ? null : index); }}
                    onPointerOver={() => isUnleashedMode && setHover(true)}
                    onPointerOut={() => setHover(false)}
                >
                    {/* ç›¸æ¡†ï¼šé€™æ˜¯å¹¾ä½•é«”ï¼Œä¸€å®šçœ‹å¾—åˆ° */}
                    <mesh position={[0,0,-0.01]}>
                        <boxGeometry args={[1.2, 1.4, 0.05]} />
                        <meshStandardMaterial color="#f0f0f0" roughness={0.8} />
                    </mesh>
                    
                    {/* ç…§ç‰‡ï¼šå¦‚æœ 404ï¼Œé€™è£¡æœƒå¤±æ•—ï¼Œä½†ä¸å½±éŸ¿ç›¸æ¡† */}
                    <DreiImage url={url} position={[0, 0.1, 0.02]} scale={[1, 0.8, 1]} transparent toneMapped={false} />
                    
                    {/* ä¸‹æ–¹ç•™ç™½æ–‡å­—å€ */}
                    <mesh position={[0, -0.5, 0.02]}>
                        <planeGeometry args={[0.9, 0.2]} />
                        <meshBasicMaterial color="#f0f0f0" />
                    </mesh>
                </group>
            );
        };

        // ç¨ç«‹çš„ç…§ç‰‡ç‰†çµ„ä»¶ (ç”¨ Suspense åŒ…è£¹)
        const PhotoGallery = ({ isFormed, isUnleashedMode, setZoomedId, zoomedId }) => {
            return (
                <>
                    {PHOTO_PATHS.map((path, i) => (
                        <Polaroid key={i} index={i} url={path} isFormed={isFormed} isUnleashedMode={isUnleashedMode} setZoomedId={setZoomedId} zoomedId={zoomedId} />
                    ))}
                </>
            );
        };

        // --- ä¸»å ´æ™¯ ---
        const Scene = ({ isFormed, setZoomedId, zoomedId }) => {
            return (
                <>
                    <PerspectiveCamera makeDefault position={[0, 4, 25]} fov={50} />
                    <OrbitControls minDistance={5} maxDistance={40} autoRotate={isFormed} autoRotateSpeed={0.8} />
                    
                    {/* åŸºç¤ç‡ˆå…‰ (ä¿åº•ï¼Œæ²’æœ‰ HDRI ä¹Ÿèƒ½çœ‹) */}
                    <ambientLight intensity={0.3} color="#ffe" />
                    <pointLight position={[10, 10, 10]} intensity={1.5} color="#FFD700" />
                    <pointLight position={[-10, -5, -10]} intensity={0.5} color="#d4af37" />

                    <group position={[0, -2, 0]}>
                        {/* 1. æ ¸å¿ƒæ¨¹æœ¨èˆ‡è£é£¾ (ç«‹åˆ»é¡¯ç¤º) */}
                        <Foliage isFormed={isFormed} />
                        <Ornaments isFormed={isFormed} />
                        
                        {/* 2. ç…§ç‰‡ç‰† (ç¨ç«‹åŠ è¼‰ï¼Œå¤±æ•—ä¸å½±éŸ¿æ¨¹) */}
                        <Suspense fallback={null}>
                            <PhotoGallery isFormed={isFormed} isUnleashedMode={!isFormed} setZoomedId={setZoomedId} zoomedId={zoomedId} />
                        </Suspense>
                    </group>

                    {/* 3. ç’°å¢ƒèˆ‡å¾Œè£½ (ç¨ç«‹åŠ è¼‰) */}
                    <Suspense fallback={null}>
                        <Environment preset="lobby" />
                    </Suspense>

                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.8} mipmapBlur intensity={1.5} radius={0.5} />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </>
            );
        };

        // --- UI èˆ‡æ‡‰ç”¨å…¥å£ ---
        const App = () => {
            const [mode, setMode] = useState('FORMED');
            const [zoomedId, setZoomedId] = useState(null);
            
            return (
                <>
                    {/* 3D å±¤ */}
                    <Canvas gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }} dpr={[1, 1.5]}>
                        <color attach="background" args={['#000501']} />
                        <Scene isFormed={mode==='FORMED'} setZoomedId={setZoomedId} zoomedId={zoomedId} />
                    </Canvas>

                    {/* UI å±¤ (ç¨ç«‹æ–¼ Canvas) */}
                    <div id="ui-layer" className="flex flex-col justify-between p-8">
                        <header className="text-center mt-4 drop-shadow-lg">
                            <h1 className="text-4xl md:text-6xl text-[#d4af37] font-bold luxury-font tracking-widest">
                                <span className="text-3xl align-middle mr-2">ğŸ¾</span>
                                NaNa's Happy Christmas
                            </h1>
                            <p className="text-[#a4c6a4] mt-2 hand-font italic text-xl">Grand Luxury Interactive Experience</p>
                        </header>

                        <div className="flex justify-center mb-8 pointer-events-auto">
                            <button onClick={() => { setMode(m => m==='FORMED'?'CHAOS':'FORMED'); setZoomedId(null); }}
                                className="btn-luxury text-[#2a2a2a] px-12 py-4 rounded-full font-bold text-xl uppercase tracking-widest border-2 border-[#fff8e7]">
                                {mode==='FORMED' ? "UNLEASH CHAOS" : "FORM THE TREE"}
                            </button>
                        </div>

                         <div className="absolute bottom-4 right-4 text-[#d4af37]/60 text-sm font-sans text-right hidden md:block">
                            Drag to Rotate <br/> 
                            {mode==='FORMED' ? "Toggle to Unleash" : "Click Photos to Zoom"}
                        </div>
                    </div>
                    
                    {/* è®Šæš—é®ç½© */}
                    {zoomedId !== null && <div className="absolute top-0 left-0 w-full h-full bg-black/60 z-20 pointer-events-none transition-opacity duration-300" />}
                </>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
