<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêæ NaNaÁöÑÂø´Ê®ÇËÅñË™ïÁØÄ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');
        
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000501; }
        .luxury-font { font-family: 'Cinzel', serif; }
        .hand-font { font-family: 'Playfair Display', serif; }
        
        /* ËºâÂÖ•ÂãïÁï´Ëàá UI */
        .loader-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000501; z-index: 50; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #d4af37;
        }
        
        .btn-luxury {
            background: linear-gradient(135deg, #d4af37 0%, #f9f295 50%, #aa8e28 100%);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            cursor: pointer;
        }
        .btn-luxury:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.8); }
    </style>
    
    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
            "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
            "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
            "postprocessing": "https://esm.sh/postprocessing@6.34.1?external=three"
        }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Environment, Image as DreiImage, useProgress, Html } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // --- ÂúñÁâáË∑ØÂæëÈÖçÁΩÆ (ÂÖ±32Âºµ) ---
        const PHOTO_PATHS = [
            "images/INTJ_boy.jpg", "images/INTJ_girl.jpg",
            "images/INTP_boy.jpg", "images/INTP_girl.jpg",
            "images/ENTJ_boy.jpg", "images/ENTJ_girl.jpg",
            "images/ENTP_boy.jpg", "images/ENTP_girl.jpg",
            "images/INFJ_boy.jpg", "images/INFJ_girl.jpg",
            "images/INFP_boy.jpg", "images/INFP_girl.jpg",
            "images/ENFJ_boy.jpg", "images/ENFJ_girl.jpg",
            "images/ENFP_boy.jpg", "images/ENFP_girl.jpg",
            "images/ISTJ_boy.jpg", "images/ISTJ_girl.jpg",
            "images/ISFJ_boy.jpg", "images/ISFJ_girl.jpg",
            "images/ESTJ_boy.jpg", "images/ESTJ_girl.jpg",
            "images/ESFJ_boy.jpg", "images/ESFJ_girl.jpg",
            "images/ISTP_boy.jpg", "images/ISTP_girl.jpg",
            "images/ISFP_boy.jpg", "images/ISFP_girl.jpg",
            "images/ESTP_boy.jpg", "images/ESTP_girl.jpg",
            "images/ESFP_boy.jpg", "images/ESFP_girl.jpg"
        ];

        // --- Á≥ªÁµ±Â∏∏Èáè ---
        const COUNT_NEEDLES = 3000;
        const COUNT_ORNAMENTS = 150;
        const PHOTO_COUNT = 32; // ËàáÂúñÁâáÊï∏Èáè‰∏ÄËá¥
        
        const COLORS = {
            GOLD: new THREE.Color("#FFD700"),
            EMERALD: new THREE.Color("#046307"),
            DEEP_RED: new THREE.Color("#8B0000"),
            SILVER: new THREE.Color("#C0C0C0"),
            WARM_LIGHT: new THREE.Color("#FFF8E7")
        };

        // --- ËºîÂä©ÂáΩÊï∏ÔºöÂ∫ßÊ®ôÁîüÊàê ---
        function getChaosPosition(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = radius * Math.cbrt(Math.random());
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        function getTreePosition(i, count, radiusBase, height) {
            const y = (i / count) * height; 
            const radius = radiusBase * (1 - y / height);
            const angle = i * 137.5 * (Math.PI / 180);
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            return new THREE.Vector3(x, y - height / 2, z);
        }

        // --- ËºâÂÖ•ÊèêÁ§∫ÁµÑ‰ª∂ ---
        function Loader() {
            const { progress } = useProgress();
            return (
                <Html center>
                    <div className="text-[#d4af37] text-xl luxury-font text-center whitespace-nowrap bg-black/80 p-4 rounded-lg border border-[#d4af37]">
                        Loading Memories... {progress.toFixed(0)}%
                    </div>
                </Html>
            );
        }

        // --- 3D Áâ©‰ª∂ÁµÑ‰ª∂ ---

        // 1. ÈáùËëâ
        const Foliage = ({ isFormed }) => {
            const pointsRef = useRef();
            
            const { positions, targets, chaos } = useMemo(() => {
                const pos = new Float32Array(COUNT_NEEDLES * 3);
                const targets = [];
                const chaos = [];
                
                for (let i = 0; i < COUNT_NEEDLES; i++) {
                    const t = getTreePosition(i, COUNT_NEEDLES, 6, 14);
                    targets.push(t);
                    const c = getChaosPosition(15);
                    chaos.push(c);
                    pos[i*3] = c.x; pos[i*3+1] = c.y; pos[i*3+2] = c.z;
                }
                return { positions: pos, targets, chaos };
            }, []);

            useFrame((state, delta) => {
                if (!pointsRef.current) return;
                const attr = pointsRef.current.geometry.attributes.position;
                
                for (let i = 0; i < COUNT_NEEDLES; i++) {
                    const ix = i * 3;
                    const cur = new THREE.Vector3(attr.array[ix], attr.array[ix+1], attr.array[ix+2]);
                    const tgt = isFormed ? targets[i] : chaos[i];
                    
                    cur.lerp(tgt, isFormed ? 0.05 : 0.02);
                    
                    if (!isFormed) cur.y += Math.sin(state.clock.elapsedTime + i) * 0.01;
                    
                    attr.array[ix] = cur.x; attr.array[ix+1] = cur.y; attr.array[ix+2] = cur.z;
                }
                attr.needsUpdate = true;
            });

            return (
                <points ref={pointsRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={COUNT_NEEDLES} array={positions} itemSize={3} />
                    </bufferGeometry>
                    <pointsMaterial size={0.15} color={COLORS.EMERALD} transparent opacity={0.8} sizeAttenuation blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        // 2. Ë£ùÈ£æÁêÉ
        const Ornaments = ({ isFormed }) => {
            const meshRef = useRef();
            const tempObj = new THREE.Object3D();
            
            const data = useMemo(() => new Array(COUNT_ORNAMENTS).fill(0).map((_, i) => {
                const t = getTreePosition(i, COUNT_ORNAMENTS, 6.5, 14);
                t.x += (Math.random()-0.5); t.z += (Math.random()-0.5);
                return { 
                    t, 
                    c: getChaosPosition(18), 
                    color: Math.random()>0.6 ? COLORS.GOLD : (Math.random()>0.5 ? COLORS.DEEP_RED : COLORS.SILVER),
                    scale: Math.random()*0.4 + 0.2,
                    current: getChaosPosition(18)
                };
            }), []);

            useFrame(() => {
                if (!meshRef.current) return;
                data.forEach((obj, i) => {
                    const target = isFormed ? obj.t : obj.c;
                    obj.current.lerp(target, 0.03);
                    tempObj.position.copy(obj.current);
                    
                    if (!isFormed) {
                        tempObj.rotation.x += 0.01;
                        tempObj.rotation.y += 0.01;
                    } else {
                        tempObj.rotation.set(0,0,0);
                    }
                    tempObj.scale.setScalar(obj.scale);
                    tempObj.updateMatrix();
                    meshRef.current.setMatrixAt(i, tempObj.matrix);
                    meshRef.current.setColorAt(i, obj.color);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
            });

            return (
                <instancedMesh ref={meshRef} args={[null, null, COUNT_ORNAMENTS]}>
                    <sphereGeometry args={[1, 16, 16]} />
                    <meshStandardMaterial color="#fff" roughness={0.1} metalness={0.9} />
                </instancedMesh>
            );
        };

        // 3. ÊãçÁ´ãÂæóÁÖßÁâá
        const Polaroid = ({ index, isFormed, isUnleashedMode, setZoomedId, zoomedId, url }) => {
            const groupRef = useRef();
            const [hovered, setHover] = useState(false);
            
            const { treePos, chaosPos, rotChaos } = useMemo(() => {
                const t = getTreePosition(index, PHOTO_COUNT, 7, 12);
                t.y += 1;
                return { 
                    treePos: t, 
                    chaosPos: getChaosPosition(22),
                    rotChaos: [Math.random()*Math.PI, Math.random()*Math.PI, 0]
                };
            }, [index]);

            useFrame((state) => {
                if (!groupRef.current) return;
                const isZoomed = zoomedId === index;
                let tPos = new THREE.Vector3();
                let tRot = new THREE.Euler();
                let tScale = 1;

                if (isZoomed) {
                    // Zoom logic
                    const cam = state.camera;
                    const fwd = new THREE.Vector3(0,0,-6).applyQuaternion(cam.quaternion);
                    tPos.copy(cam.position).add(fwd);
                    tRot.copy(cam.rotation);
                    tScale = 2.5;
                } else {
                    tPos = isFormed ? treePos : chaosPos;
                    if (isFormed) {
                        groupRef.current.lookAt(0, tPos.y, 0);
                        tRot.copy(groupRef.current.rotation);
                    } else {
                        tRot.set(...rotChaos);
                        tPos.y += Math.sin(state.clock.elapsedTime + index)*0.05;
                    }
                    tScale = (hovered && isUnleashedMode && !zoomedId) ? 1.3 : 1;
                }

                // Smooth animation
                groupRef.current.position.lerp(tPos, 0.08);
                const q = new THREE.Quaternion().setFromEuler(tRot);
                groupRef.current.quaternion.slerp(q, 0.1);
                groupRef.current.scale.lerp(new THREE.Vector3(tScale,tScale,tScale), 0.1);
            });

            return (
                <group ref={groupRef} 
                    onClick={(e) => { e.stopPropagation(); if(isUnleashedMode) setZoomedId(zoomedId === index ? null : index); }}
                    onPointerOver={() => isUnleashedMode && setHover(true)}
                    onPointerOut={() => setHover(false)}
                >
                    {/* Polaroid Frame */}
                    <mesh position={[0,0,-0.01]}>
                        <boxGeometry args={[1.2, 1.4, 0.05]} />
                        <meshStandardMaterial color="#eee" roughness={0.9} />
                    </mesh>
                    {/* Photo Image */}
                    <DreiImage 
                        url={url} 
                        position={[0, 0.1, 0.02]} 
                        scale={[1, 0.8, 1]} 
                        transparent 
                        toneMapped={false} // ‰øùÊåÅÂúñÁâáÈÆÆË±î
                    />
                    {/* Text Area */}
                     <mesh position={[0, -0.5, 0.02]}>
                        <planeGeometry args={[0.9, 0.2]} />
                        <meshBasicMaterial color="#eee" />
                    </mesh>
                </group>
            );
        };

        // --- ‰∏ªÂ†¥ÊôØ ---
        const Scene = ({ isFormed, setZoomedId, zoomedId }) => {
            // ‰ΩøÁî®ÂÆöÁæ©Â•ΩÁöÑ PHOTO_PATHS ‰æÜÁîüÊàêÁÖßÁâáÊï∏Êìö
            const photos = useMemo(() => PHOTO_PATHS.map((path, i) => ({
                id: i,
                url: path
            })), []);

            return (
                <>
                    <PerspectiveCamera makeDefault position={[0, 4, 25]} fov={50} />
                    <OrbitControls minDistance={5} maxDistance={40} autoRotate={isFormed} autoRotateSpeed={0.8} />

                    {/* Lighting & Environment */}
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={1} color="#FFD700" />
                    <pointLight position={[-10, -5, -10]} intensity={0.5} color="#d4af37" />
                    <Environment preset="lobby" />

                    <group position={[0, -2, 0]}>
                        <Foliage isFormed={isFormed} />
                        <Ornaments isFormed={isFormed} />
                        
                        {photos.map(p => (
                            <Polaroid 
                                key={p.id} 
                                index={p.id} 
                                url={p.url} 
                                isFormed={isFormed} 
                                isUnleashedMode={!isFormed} 
                                setZoomedId={setZoomedId} 
                                zoomedId={zoomedId} 
                            />
                        ))}
                    </group>

                    <EffectComposer disableNormalPass>
                        <Bloom luminanceThreshold={0.8} mipmapBlur intensity={1.5} radius={0.5} />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    </EffectComposer>
                </>
            );
        };

        // --- ÊáâÁî®ÂÖ•Âè£ ---
        const App = () => {
            const [mode, setMode] = useState('FORMED');
            const [zoomedId, setZoomedId] = useState(null);
            
            return (
                <>
                    <Canvas gl={{ antialias: false, toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }} dpr={[1, 1.5]}>
                        <color attach="background" args={['#000501']} />
                        <Suspense fallback={<Loader />}>
                            <Scene isFormed={mode==='FORMED'} setZoomedId={setZoomedId} zoomedId={zoomedId} />
                        </Suspense>
                    </Canvas>

                    <div className="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-8 z-10">
                        <header className="text-center mt-4 drop-shadow-lg">
                            <h1 className="text-4xl md:text-6xl text-[#d4af37] font-bold luxury-font tracking-widest">
                                <span className="text-3xl align-middle mr-2">üêæ</span>
                                NaNa's Happy Christmas
                            </h1>
                            <p className="text-[#a4c6a4] mt-2 hand-font italic text-xl">Grand Luxury Interactive Experience</p>
                        </header>

                        <div className="pointer-events-auto flex justify-center mb-8">
                            <button onClick={() => { setMode(m => m==='FORMED'?'CHAOS':'FORMED'); setZoomedId(null); }}
                                className="btn-luxury text-[#2a2a2a] px-12 py-4 rounded-full font-bold text-xl uppercase tracking-widest border-2 border-[#fff8e7]">
                                {mode==='FORMED' ? "UNLEASH CHAOS" : "FORM THE TREE"}
                            </button>
                        </div>
                        
                        <div className="absolute bottom-4 right-4 text-[#d4af37]/60 text-sm font-sans text-right hidden md:block">
                             Drag to Rotate <br/> 
                            {mode==='FORMED' ? "Toggle to Unleash" : "Click Photos to Zoom"}
                        </div>
                    </div>
                    {zoomedId !== null && (
                        <div className="absolute top-0 left-0 w-full h-full bg-black/60 z-0 pointer-events-none transition-opacity duration-300" />
                    )}
                </>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>